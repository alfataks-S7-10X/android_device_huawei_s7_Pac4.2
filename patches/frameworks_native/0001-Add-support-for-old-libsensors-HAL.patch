From 46b25e2174340d0c669b01cb7e4d59d66844ba6b Mon Sep 17 00:00:00 2001
From: asturel <astur3l@gmail.com>
Date: Fri, 30 Nov 2012 06:57:48 -0700
Subject: [PATCH] Add support for old libsensors HAL

Change-Id: Ib6f1391e27376f47cdf3a69b790a9a5c33a954bc
---
 services/sensorservice/Android.mk           |    8 ++
 services/sensorservice/SensorDevice.cpp     |  155 ++++++++++++++++++++++++---
 services/sensorservice/SensorDevice.h       |    8 ++
 services/sensorservice/sensors_deprecated.h |   75 +++++++++++++
 4 files changed, 232 insertions(+), 14 deletions(-)
 create mode 100644 services/sensorservice/sensors_deprecated.h

diff --git a/services/sensorservice/Android.mk b/services/sensorservice/Android.mk
index e0cfaa6..4e02e62 100644
--- a/services/sensorservice/Android.mk
+++ b/services/sensorservice/Android.mk
@@ -27,6 +27,14 @@ LOCAL_SHARED_LIBRARIES := \
 
 
 
+ifeq ($(TARGET_USES_OLD_LIBSENSORS_HAL),true)
+    LOCAL_CFLAGS += -DENABLE_SENSORS_COMPAT
+endif
+
+ifeq ($(TARGET_SENSORS_NO_OPEN_CHECK),true)
+    LOCAL_CFLAGS += -DSENSORS_NO_OPEN_CHECK
+endif 
+
 LOCAL_MODULE:= libsensorservice
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/sensorservice/SensorDevice.cpp b/services/sensorservice/SensorDevice.cpp
index a9e3ef4..4e2fa7c 100644
--- a/services/sensorservice/SensorDevice.cpp
+++ b/services/sensorservice/SensorDevice.cpp
@@ -31,6 +31,11 @@
 #include "SensorDevice.h"
 #include "SensorService.h"
 
+#ifdef ENABLE_SENSORS_COMPAT
+#include "sensors_deprecated.h"
+#endif
+
+
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -38,6 +43,8 @@ ANDROID_SINGLETON_STATIC_INSTANCE(SensorDevice)
 
 SensorDevice::SensorDevice()
     :  mSensorDevice(0),
+       mOldSensorsEnabled(0),
+       mOldSensorsCompatMode(false),
        mSensorModule(0)
 {
     status_t err = hw_get_module(SENSORS_HARDWARE_MODULE_ID,
@@ -47,19 +54,51 @@ SensorDevice::SensorDevice()
             SENSORS_HARDWARE_MODULE_ID, strerror(-err));
 
     if (mSensorModule) {
+#ifdef ENABLE_SENSORS_COMPAT
+#ifdef SENSORS_NO_OPEN_CHECK
+        sensors_control_open(&mSensorModule->common, &mSensorControlDevice) ;
+        sensors_data_open(&mSensorModule->common, &mSensorDataDevice) ;
+        mOldSensorsCompatMode = true;
+#else
+        if (!sensors_control_open(&mSensorModule->common, &mSensorControlDevice)) {
+            if (sensors_data_open(&mSensorModule->common, &mSensorDataDevice)) {
+                ALOGE("couldn't open data device in backwards-compat mode for module %s (%s)",
+                        SENSORS_HARDWARE_MODULE_ID, strerror(-err));
+            } else {
+                ALOGD("Opened sensors in backwards compat mode");
+                mOldSensorsCompatMode = true;
+            }
+        } else {
+            ALOGE("couldn't open control device in backwards-compat mode for module %s (%s)",
+                    SENSORS_HARDWARE_MODULE_ID, strerror(-err));
+        }
+#endif
+#else
         err = sensors_open(&mSensorModule->common, &mSensorDevice);
-
+#endif
         ALOGE_IF(err, "couldn't open device for module %s (%s)",
                 SENSORS_HARDWARE_MODULE_ID, strerror(-err));
 
-        if (mSensorDevice) {
+        if (mSensorDevice  || mOldSensorsCompatMode) {
             sensor_t const* list;
             ssize_t count = mSensorModule->get_sensors_list(mSensorModule, &list);
+			
+			if (mOldSensorsCompatMode) {
+                mOldSensorsList = list;
+                mOldSensorsCount = count;
+                mSensorDataDevice->data_open(mSensorDataDevice,
+                mSensorControlDevice->open_data_source(mSensorControlDevice));
+            }
+			
             mActivationCount.setCapacity(count);
             Info model;
             for (size_t i=0 ; i<size_t(count) ; i++) {
                 mActivationCount.add(list[i].handle, model);
-                mSensorDevice->activate(mSensorDevice, list[i].handle, 0);
+				 if (mOldSensorsCompatMode) {
+					mSensorControlDevice->activate(mSensorControlDevice, list[i].handle, 0);
+                } else {
+					mSensorDevice->activate(mSensorDevice, list[i].handle, 0);
+				}
             }
         }
     }
@@ -99,21 +138,88 @@ ssize_t SensorDevice::getSensorList(sensor_t const** list) {
 }
 
 status_t SensorDevice::initCheck() const {
-    return mSensorDevice && mSensorModule ? NO_ERROR : NO_INIT;
+    return (mSensorDevice || mOldSensorsCompatMode) && mSensorModule ? NO_ERROR : NO_INIT;
 }
 
 ssize_t SensorDevice::poll(sensors_event_t* buffer, size_t count) {
-    if (!mSensorDevice) return NO_INIT;
+    if (!mSensorDevice  && !mOldSensorsCompatMode) return NO_INIT;
     ssize_t c;
-    do {
-        c = mSensorDevice->poll(mSensorDevice, buffer, count);
-    } while (c == -EINTR);
-    return c;
+	    if (mOldSensorsCompatMode) {
+        size_t pollsDone = 0;
+        //LOGV("%d buffers were requested",count);
+        while (!mOldSensorsEnabled) {
+            sleep(1);
+            ALOGV("Waiting...");
+        }
+        while (pollsDone < (size_t)mOldSensorsEnabled && pollsDone < count) {
+            sensors_data_t oldBuffer;
+            long result =  mSensorDataDevice->poll(mSensorDataDevice, &oldBuffer);
+            int sensorType = -1;
+            int maxRange = -1;
+ 
+            if (result == 0x7FFFFFFF) {
+                continue;
+            } else {
+                /* the old data_poll is supposed to return a handle,
+                 * which has to be mapped to the type. */
+                for (size_t i=0 ; i<size_t(mOldSensorsCount) && sensorType < 0 ; i++) {
+                    if (mOldSensorsList[i].handle == result) {
+                        sensorType = mOldSensorsList[i].type;
+                        maxRange = mOldSensorsList[i].maxRange;
+                        ALOGV("mapped sensor type to %d",sensorType);
+                    }
+                }
+            }
+            if ( sensorType <= 0 ||
+                 sensorType > SENSOR_TYPE_ROTATION_VECTOR) {
+                ALOGV("Useless output at round %u from %d",pollsDone, oldBuffer.sensor);
+                count--;
+                continue;
+            }
+            buffer[pollsDone].version = sizeof(struct sensors_event_t);
+            buffer[pollsDone].timestamp = oldBuffer.time;
+            buffer[pollsDone].type = sensorType;
+            buffer[pollsDone].sensor = result;
+            /* This part is a union. Regardless of the sensor type,
+             * we only need to copy a sensors_vec_t and a float */
+            buffer[pollsDone].acceleration = oldBuffer.vector;
+            buffer[pollsDone].temperature = oldBuffer.temperature;
+            ALOGV("Adding results for sensor %d", buffer[pollsDone].sensor);
+            /* The ALS and PS sensors only report values on change,
+             * instead of a data "stream" like the others. So don't wait
+             * for the number of requested samples to fill, and deliver
+             * it immediately */
+            if (sensorType == SENSOR_TYPE_PROXIMITY) {
+#ifdef FOXCONN_SENSORS
+            /* Fix ridiculous API breakages from FIH. */
+            /* These idiots are returning -1 for FAR, and 1 for NEAR */
+                if (buffer[pollsDone].distance > 0) {
+                    buffer[pollsDone].distance = 0;
+                } else {
+                    buffer[pollsDone].distance = 1;
+                }
+#elif defined(PROXIMITY_LIES)
+                if (buffer[pollsDone].distance >= PROXIMITY_LIES)
+			buffer[pollsDone].distance = maxRange;
+#endif
+                return pollsDone+1;
+            } else if (sensorType == SENSOR_TYPE_LIGHT) {
+                return pollsDone+1;
+            }
+            pollsDone++;
+        }
+        return pollsDone;
+    } else {
+		do {
+			c = mSensorDevice->poll(mSensorDevice, buffer, count);
+		} while (c == -EINTR);
+		return c;
+	}
 }
 
 status_t SensorDevice::activate(void* ident, int handle, int enabled)
 {
-    if (!mSensorDevice) return NO_INIT;
+    if (!mSensorDevice  && !mOldSensorsCompatMode) return NO_INIT;
     status_t err(NO_ERROR);
     bool actuateHardware = false;
 
@@ -155,7 +261,20 @@ status_t SensorDevice::activate(void* ident, int handle, int enabled)
     if (actuateHardware) {
         ALOGD_IF(DEBUG_CONNECTIONS, "\t>>> actuating h/w");
 
-        err = mSensorDevice->activate(mSensorDevice, handle, enabled);
+		if (mOldSensorsCompatMode) {
+            if (enabled)
+                mOldSensorsEnabled++;
+            else if (mOldSensorsEnabled > 0)
+                mOldSensorsEnabled--;
+            ALOGV("Activation for %d (%d)",handle,enabled);
+            if (enabled) {
+                mSensorControlDevice->wake(mSensorControlDevice);
+            }
+            err = mSensorControlDevice->activate(mSensorControlDevice, handle, enabled);
+            err = 0;
+        } else {
+			err = mSensorDevice->activate(mSensorDevice, handle, enabled);
+		}
         ALOGE_IF(err, "Error %s sensor %d (%s)",
                 enabled ? "activating" : "disabling",
                 handle, strerror(-err));
@@ -164,7 +283,11 @@ status_t SensorDevice::activate(void* ident, int handle, int enabled)
     { // scope for the lock
         Mutex::Autolock _l(mLock);
         nsecs_t ns = info.selectDelay();
-        mSensorDevice->setDelay(mSensorDevice, handle, ns);
+		if (mOldSensorsCompatMode) {
+            mSensorControlDevice->set_delay(mSensorControlDevice, (ns/(1000*1000)));
+        } else {
+			mSensorDevice->setDelay(mSensorDevice, handle, ns);
+		}
     }
 
     return err;
@@ -172,13 +295,17 @@ status_t SensorDevice::activate(void* ident, int handle, int enabled)
 
 status_t SensorDevice::setDelay(void* ident, int handle, int64_t ns)
 {
-    if (!mSensorDevice) return NO_INIT;
+    if (!mSensorDevice  && !mOldSensorsCompatMode) return NO_INIT;
     Mutex::Autolock _l(mLock);
     Info& info( mActivationCount.editValueFor(handle) );
     status_t err = info.setDelayForIdent(ident, ns);
     if (err < 0) return err;
     ns = info.selectDelay();
-    return mSensorDevice->setDelay(mSensorDevice, handle, ns);
+	 if (mOldSensorsCompatMode) {
+        return mSensorControlDevice->set_delay(mSensorControlDevice, (ns/(1000*1000)));
+    } else {
+		return mSensorDevice->setDelay(mSensorDevice, handle, ns);
+	}
 }
 
 // ---------------------------------------------------------------------------
diff --git a/services/sensorservice/SensorDevice.h b/services/sensorservice/SensorDevice.h
index 728b6cb..b031a42 100644
--- a/services/sensorservice/SensorDevice.h
+++ b/services/sensorservice/SensorDevice.h
@@ -36,6 +36,14 @@ static const nsecs_t DEFAULT_EVENTS_PERIOD = 200000000; //    5 Hz
 class SensorDevice : public Singleton<SensorDevice> {
     friend class Singleton<SensorDevice>;
     struct sensors_poll_device_t* mSensorDevice;
+    struct sensors_data_device_t* mSensorDataDevice;
+    struct sensors_control_device_t* mSensorControlDevice;
+    int32_t mOldSensorsEnabled;
+    bool mOldSensorsCompatMode;
+    native_handle_t *mOldSensorsDataChannel;
+    sensor_t const* mOldSensorsList;
+    int mOldSensorsCount;
+
     struct sensors_module_t* mSensorModule;
     mutable Mutex mLock; // protect mActivationCount[].rates
     // fixed-size array after construction
diff --git a/services/sensorservice/sensors_deprecated.h b/services/sensorservice/sensors_deprecated.h
new file mode 100644
index 0000000..efaf6ba
--- /dev/null
+++ b/services/sensorservice/sensors_deprecated.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define SENSORS_HARDWARE_CONTROL    "control"
+#define SENSORS_HARDWARE_DATA       "data"
+
+namespace android {
+
+typedef struct {
+    int             sensor;
+    union {
+        sensors_vec_t   vector;
+        sensors_vec_t   orientation;
+        sensors_vec_t   acceleration;
+        sensors_vec_t   magnetic;
+        float           temperature;
+        float           distance;
+        float           light;
+    };
+    int64_t         time;
+    uint32_t        reserved;
+} sensors_data_t;
+
+struct sensors_control_device_t {
+    struct hw_device_t common;
+    native_handle_t* (*open_data_source)(struct sensors_control_device_t *dev);
+    int (*close_data_source)(struct sensors_control_device_t *dev);
+    int (*activate)(struct sensors_control_device_t *dev, 
+            int handle, int enabled);
+    int (*set_delay)(struct sensors_control_device_t *dev, int32_t ms);
+    int (*wake)(struct sensors_control_device_t *dev);
+};
+
+struct sensors_data_device_t {
+    struct hw_device_t common;
+    int (*data_open)(struct sensors_data_device_t *dev, native_handle_t* nh);
+    int (*data_close)(struct sensors_data_device_t *dev);
+    int (*poll)(struct sensors_data_device_t *dev, 
+            sensors_data_t* data);
+};
+
+static inline int sensors_control_open(const struct hw_module_t* module, 
+        struct sensors_control_device_t** device) {
+    return module->methods->open(module, 
+            SENSORS_HARDWARE_CONTROL, (struct hw_device_t**)device);
+}
+
+static inline int sensors_control_close(struct sensors_control_device_t* device) {
+    return device->common.close(&device->common);
+}
+
+static inline int sensors_data_open(const struct hw_module_t* module, 
+        struct sensors_data_device_t** device) {
+    return module->methods->open(module, 
+            SENSORS_HARDWARE_DATA, (struct hw_device_t**)device);
+}
+
+static inline int sensors_data_close(struct sensors_data_device_t* device) {
+    return device->common.close(&device->common);
+}
+
+};
-- 
1.7.5.4

